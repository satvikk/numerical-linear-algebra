version
a = runif(10*10000)
a = runif(10*100000)
a2 = matrix(a,ncol = 10)
View(a2)
View(a2)
a = runif(10*10000)
a2 = matrix(a,ncol = 10)
a = runif(10*1000)
a2 = matrix(a,ncol = 10)
?dist
dist(c(1,2,3))
class(dist(c(1,2,3)))
as.matrix(dist(c(1,2,3)))
b  = matrix(c(1,2,1,2,3,4,5,6),ncol=2)
b
dist(b)
as.matrix(dist(b))
ax = as.matrix(dist(a2))
ax = c(as.matrix(dist(a2)))
summary(a)
summary(ax)
hist(ax)
quantile(ax,0.9)
quantile(ax,0.98)
quantile(ax,0.95)
a = runif(10*10000)
a2 = matrix(a,ncol = 10)
ax = c(as.matrix(dist(a2)))
summary(ax)
hist(ax)
quantile(ax,0.95)
quantile(ax,c(0.95.0.96,0.97,0.98,0.99))
quantile(ax,0.94,0.5)
quantile(ax,0.99)
quantile(ax,0.98)
a
a = 4
a
1+
`+`
installed.packages('Rcpp')
install.packages('Rcpp')
library(Rcpp)
cppFunction('int add(int x, int y, int z) {
int sum = x + y + z;
return sum;
}')
add
add(1,2,3)
add(c(1,2),2,3)
add
cppFunction(
"int one(){
return 1
}"
)
cppFunction(
"int one(){
return 1;
}"
)
one()
cppFunction(
"double sumC(NumericVector x){
int n = x.size();
double total = 0;
for(int i =0; i < n; i++){
total += x[i];
}
return total;"
)
cppFunction(
"double sumC(NumericVector x){
int n = x.size();
double total = 0;
for(int i = 0; i < n; i++){
total += x[i];
}
return total;
}"
)
sumC(1)
sumC(1,2)
sumC(c(1,2))
sumC(c(1,2,3,4,5))
x = runif(1e3)
microbenchmark()
??microbenchmark
install.packages('microbenchmark')
library(microbenchmark)
microbenchmark(sum(1e4))
microbenchmark(sum(1e4), sumC(1e4))
cppFunction('NumericVector pdistC(double x, NumericVector ys) {
int n = ys.size();
NumericVector out(n);
for(int i = 0; i < n; ++i) {
out[i] = sqrt(pow(ys[i] - x, 2.0));
}
return out;
}')
pdistC(1,1:5)
pdistC(1,2:5)
pdistC(4,2:5)
sourceCpp("/home/satvik/fun_with_r/sampe_cpp.cpp")
sourceCpp("/home/satvik/fun_with_r/sampe_cpp.cpp")
sourceCpp("/home/satvik/fun_with_r/sampe_cpp.cpp")
sourceCpp("/home/satvik/fun_with_r/sampe_cpp.cpp")
one()
rm(one)
rm(add)
rm(pdistC())
rm(pdistC
)
rm(sumC)
sourceCpp("/home/satvik/fun_with_r/sampe_cpp.cpp")
sourceCpp("/home/satvik/fun_with_r/sampe_cpp.cpp")
add(2,4,3)
cppFunction("int f4(Function pred, List x) {
int n = x.size();
for(int i = 0; i < n; ++i) {
LogicalVector res = pred(x[i]);
if (res[0]) return i + 1;
}
return 0;
}")
f4(sum,list(1,2,3))
all()
all
?all
sourceCpp("/home/satvik/fun_with_r/exercise.cpp")
sourceCpp("/home/satvik/fun_with_r/exercise1.cpp")
sourceCpp("/home/satvik/fun_with_r/excercise1.cpp")
sourceCpp("/home/satvik/fun_with_r/excercise1.cpp")
allC(rep(T,5))
allC(c(T,T,T,T))
allC(c(T,T,T,F))
cumprod
?cumprod
cumprod(1:5)
sourceCpp("/home/satvik/fun_with_r/excercise1.cpp")
cumprod(1:5)
cummin
sourceCpp("/home/satvik/fun_with_r/excercise1.cpp")
cumminC()
a = sample(10,5)
a
cumminC(a)
sourceCpp("/home/satvik/fun_with_r/excercise1.cpp")
cumminC(a)
cumminC(a)
sourceCpp("/home/satvik/fun_with_r/excercise1.cpp")
cumminC(a)
library(Rcpp)
sourceCpp("/home/satvik/fun_with_r/sampe_cpp.cpp")
sourceCpp("/home/satvik/fun_with_r/excercise1.cpp")
attribs()
a=attribs()
a
class(a)
setwd("~/linal/numerical-linear-algebra/r")
800*70
numeric(NA)
as.numeric(NA)
L = matrix(as.numeric(NA), nrow = nrow(A), ncol(A))
A = matrix(100,100)
A
A = matrix(100,10)
A
A = matrix(100,10,10)
A
class(A)
cholesky1 <- function(A){
if(class(A) != "matrix")
stop(paste0("found ",class(A), "expected matrix"))
if(ncol(A) != nrow(A))
stop("not a square matrix")
L = matrix(as.numeric(NA), nrow = nrow(A), ncol(A))
}
cholesky1()
cholesky1("fsd")
cholesky1 <- function(A){
if(class(A) != "matrix")
stop(paste0("found ",class(A), ", expected matrix"))
if(ncol(A) != nrow(A))
stop("not a square matrix")
L = matrix(as.numeric(NA), nrow = nrow(A), ncol(A))
}
cholesky1("fsd")
roots = numeric(nrow(A))
roots
A = matrix(runif(100), ncol = 10, nrow = 10)
roots = numeric(nrow(A))
roots
roots = rep(as.numeric(NA), nrow(A))
roots
L = matrix(as.numeric(NA), nrow = nrow(A), ncol = ncol(A))
L
roots[1] = sqrt(A[1,1])
roots
L[,1, with = T]
L[,1, drop = F]
L[1,1] = sqrt(A[1,1])
L[,1, drop = F]
A[,1,drop=F]
L[,1,drop=F] = A[,1,drop=F]/L[1,1]
L[,1,drop=F] = A[,1,drop=F]/L[1,1]
L[,1,drop=F]
A[,1,drop=F]
A[,1,drop=F]/L[1,1]
L[,1] = A[,1]/L[1,1]
L[,1]
L = matrix(as.numeric(NA), nrow = nrow(A), ncol = ncol(A))
L[1,1] = sqrt(A[1,1])
L[,1] = A[,1]/L[1,1]
L
L[-1,1]
L = matrix(as.numeric(NA), nrow = nrow(A), ncol = ncol(A))
L[-1,1]
L = matrix(as.numeric(NA), nrow = nrow(A), ncol = ncol(A))
L[1,1] = sqrt(A[1,1])
L[-1,1] = A[-1,1]/L[1,1]
L
i = 2
L[,i, drop = F]
L[,i]
L[-(1:i),i]
L[i,]
L[i,,drop=F]
i
L[i,-(i:n),drop=F]
n = ncol(A)
L[i,-(i:n),drop=F]
L[i,-(i:n),drop=F] %*% L[i,-(i:n),drop=F]
L[i,-(i:n)]
L[i,i] = sqrt(A[i,i] - sum(L[i,-(i:n)]^2) )
A
L
sqrt(A[i,i]
sqrt(A[i,i] - sum(L[i,-(i:n)]^2) )
sum(L[i,-(i:n)]^2)
A[i,i]
A = A %*% t(A)
n = ncol(A)
L = matrix(as.numeric(NA), nrow = n, ncol = n)
L[1,1] = sqrt(A[1,1])
L[-1,1] = A[-1,1]/L[1,1]
L
A
n = ncol(A)
L = matrix(as.numeric(NA), nrow = n, ncol = n)
L[1,1] = sqrt(A[1,1])
L[-1,1] = A[-1,1]/L[1,1]
L[i,i] = sqrt(A[i,i] - sum(L[i,-(i:n)]^2) )
L
L[-(1:i),i]
A[-(1:i),i,drop=F] %>% dim
library(magrittr)
install.packages("magrittr")
library(magrittr)
A[-(1:i),i,drop=F] %>% dim
L[-(1:i),1:(i-1),drop=F]
t(L[i,,drop=F])
t(L[i,1:(i-1),drop=F])
L[-(1:i),1:(i-1),drop=F] %*% t(L[i,1:(i-1),drop=F])
A[-(1:i),i,drop=F] - L[-(1:i),1:(i-1),drop=F] %*% t(L[i,1:(i-1),drop=F])
L[-(1:i),i,drop=F] = A[-(1:i),i,drop=F] - L[-(1:i),1:(i-1),drop=F] %*% t(L[i,1:(i-1),drop=F])
A[-(1:i),i,drop=F] - L[-(1:i),1:(i-1),drop=F] %*% t(L[i,1:(i-1),drop=F])
L[-(1:i),i,drop=F]
L[-(1:i),i] = c(A[-(1:i),i,drop=F] - L[-(1:i),1:(i-1),drop=F] %*% t(L[i,1:(i-1),drop=F]))
L
cholesky1 <- function(A){
if(class(A) != "matrix")
stop(paste0("found ",class(A), ", expected matrix"))
if((ncol(A) != nrow(A)) | nrow(A) <= 3)
stop("not a square matrix of n>3")
n = ncol(A)
L = matrix(as.numeric(NA), nrow = n, ncol = n)
L[1,1] = sqrt(A[1,1])
L[-1,1] = A[-1,1]/L[1,1]
for(i in 1:(ncol(A)-1)){
L[i,i] = sqrt(A[i,i] - sum(L[i,-(i:n)]^2) )
L[-(1:i),i] = c(A[-(1:i),i,drop=F] - L[-(1:i),1:(i-1),drop=F] %*% t(L[i,1:(i-1),drop=F]))
}
L[n,n] = sqrt(A[n,n] - sum(L[n,-n]^2) )
}
cholesky1(A)
cholesky1 <- function(A){
if(class(A) != "matrix")
stop(paste0("found ",class(A), ", expected matrix"))
if((ncol(A) != nrow(A)) | nrow(A) <= 3)
stop("not a square matrix of n>3")
n = ncol(A)
L = matrix(as.numeric(NA), nrow = n, ncol = n)
L[1,1] = sqrt(A[1,1])
L[-1,1] = A[-1,1]/L[1,1]
for(i in 1:(ncol(A)-1)){
L[i,i] = sqrt(A[i,i] - sum(L[i,-(i:n)]^2) )
L[-(1:i),i] = c(A[-(1:i),i,drop=F] - L[-(1:i),1:(i-1),drop=F] %*% t(L[i,1:(i-1),drop=F]))
}
L[n,n] = sqrt(A[n,n] - sum(L[n,-n]^2) )
return(L)
}
cholesky1(A)
cholesky1 <- function(A){
if(class(A) != "matrix")
stop(paste0("found ",class(A), ", expected matrix"))
if((ncol(A) != nrow(A)) | nrow(A) <= 3)
stop("not a square matrix of n>3")
n <- ncol(A)
L <- matrix(as.numeric(NA), nrow = n, ncol = n)
L[1,1] <- sqrt(A[1,1])
L[-1,1] <- A[-1,1]/L[1,1]
for(i in 1:(ncol(A)-1)){
L[i,i] <- sqrt(A[i,i] - sum(L[i,-(i:n)]^2) )
L[-(1:i),i] <- c(A[-(1:i),i,drop=F] - L[-(1:i),1:(i-1),drop=F] %*% t(L[i,1:(i-1),drop=F]))
}
L[n,n] <- sqrt(A[n,n] - sum(L[n,-n]^2) )
L[is.na(L)] <- 0
return(L)
}
cholesky1(A)
A
L[-1,1]
A = matrix(runif(100), ncol = 10, nrow = 10)
A = A %*% t(A)
if(class(A) != "matrix")
stop(paste0("found ",class(A), ", expected matrix"))
if((ncol(A) != nrow(A)) | nrow(A) <= 3)
stop("not a square matrix of n>3")
n <- ncol(A)
L <- matrix(as.numeric(NA), nrow = n, ncol = n)
L[1,1] <- sqrt(A[1,1])
L[-1,1] <- A[-1,1]/L[1,1]
L
cholesky1 <- function(A){
if(class(A) != "matrix")
stop(paste0("found ",class(A), ", expected matrix"))
if((ncol(A) != nrow(A)) | nrow(A) <= 3)
stop("not a square matrix of n>3")
n <- ncol(A)
L <- matrix(as.numeric(NA), nrow = n, ncol = n)
L[1,1] <- sqrt(A[1,1])
L[-1,1] <- A[-1,1]/L[1,1]
for(i in 2:(ncol(A)-1)){
L[i,i] <- sqrt(A[i,i] - sum(L[i,-(i:n)]^2) )
L[-(1:i),i] <- c(A[-(1:i),i,drop=F] - L[-(1:i),1:(i-1),drop=F] %*% t(L[i,1:(i-1),drop=F]))
}
L[n,n] <- sqrt(A[n,n] - sum(L[n,-n]^2) )
L[is.na(L)] <- 0
return(L)
}
cholesky1(A)
mat <- matrix(runif(100), ncol = 10, nrow = 10)
A <- mat %*% t(mat)
mat <- matrix(runif(100), ncol = 10, nrow = 10)
mat <- mat %*% t(mat)
l_cho = cholesky1(mat)
mat <- matrix(runif(100), ncol = 10, nrow = 10)
mat <- mat %*% t(mat)
l_cho = cholesky1(mat)
l_cho
mat
mat <- mat %*% t(mat)
mat
l_cho = cholesky1(mat)
l_cho
mat <- matrix(runif(100), ncol = 10, nrow = 10)
mat <- mat %*% t(mat)
l_cho = cholesky1(mat)
l_cho
is.na(NaN)
cholesky1 <- function(A){
if(class(A) != "matrix")
stop(paste0("found ",class(A), ", expected matrix"))
if((ncol(A) != nrow(A)) | nrow(A) <= 3)
stop("not a square matrix of n>3")
n <- ncol(A)
L <- matrix(as.numeric(NA), nrow = n, ncol = n)
L[1,1] <- sqrt(A[1,1])
L[-1,1] <- A[-1,1]/L[1,1]
for(i in 2:(ncol(A)-1)){
L[i,i] <- sqrt(A[i,i] - sum(L[i,-(i:n)]^2) )
L[-(1:i),i] <- c(A[-(1:i),i,drop=F] - L[-(1:i),1:(i-1),drop=F] %*% t(L[i,1:(i-1),drop=F]))
}
L[n,n] <- sqrt(A[n,n] - sum(L[n,-n]^2) )
#L[is.na(L)] <- 0
return(L)
}
mat <- matrix(runif(100), ncol = 10, nrow = 10)
mat <- mat %*% t(mat)
l_cho = cholesky1(mat)
l_cho
cholesky1 <- function(A){
if(class(A) != "matrix")
stop(paste0("found ",class(A), ", expected matrix"))
if((ncol(A) != nrow(A)) | nrow(A) <= 3)
stop("not a square matrix of n>3")
n <- ncol(A)
L <- matrix(as.numeric(NA), nrow = n, ncol = n)
L[1,1] <- sqrt(A[1,1])
L[-1,1] <- A[-1,1]/L[1,1]
for(i in 2:(ncol(A)-1)){
L[i,i] <- sqrt(A[i,i] - sum(L[i,-(i:n)]^2) )
L[-(1:i),i] <- c(A[-(1:i),i,drop=F] - L[-(1:i),1:(i-1),drop=F] %*% t(L[i,1:(i-1),drop=F]))
}
L[n,n] <- sqrt(A[n,n] - sum(L[n,-n]^2) )
L[is.na(L)] <- 0
return(L)
}
mat <- matrix(runif(100), ncol = 10, nrow = 10)
mat <- mat %*% t(mat)
l_cho = cholesky1(mat)
l_cho
norm((lcho %*% t(l_cho)) - mat, "F")
norm((l_cho %*% t(l_cho)) - mat, "F")
mat <- matrix(runif(100), ncol = 10, nrow = 10)
mat <- mat %*% t(mat)
l_cho = cholesky1(mat)
norm((l_cho %*% t(l_cho)) - mat, "F")
l_cho %*% t(l_cho)) - mat
(l_cho %*% t(l_cho)) - mat
cholesky1 <- function(A){
if(class(A) != "matrix")
stop(paste0("found ",class(A), ", expected matrix"))
if((ncol(A) != nrow(A)) | nrow(A) <= 3)
stop("not a square matrix of n>3")
n <- ncol(A)
L <- matrix(as.numeric(NA), nrow = n, ncol = n)
L[1,1] <- sqrt(A[1,1])
L[-1,1] <- A[-1,1]/L[1,1]
for(i in 2:(ncol(A)-1)){
L[i,i] <- sqrt(A[i,i] - sum(L[i,-(i:n)]^2) )
L[-(1:i),i] <- c(A[-(1:i),i,drop=F] - L[-(1:i),1:(i-1),drop=F] %*% t(L[i,1:(i-1),drop=F]))
}
L[n,n] <- sqrt(A[n,n] - sum(L[n,-n]^2) )
L[is.na(L)] <- 0
return(L)
}
mat <- matrix(runif(100), ncol = 10, nrow = 10)
mat <- mat %*% t(mat)
l_cho = cholesky1(mat)
norm((l_cho %*% t(l_cho)) - mat, "F")
l_cho
norm((l_cho %*% t(l_cho)) - mat, "F")
(l_cho %*% t(l_cho)) - mat
cholesky1 <- function(A){
if(class(A) != "matrix")
stop(paste0("found ",class(A), ", expected matrix"))
if((ncol(A) != nrow(A)) | nrow(A) <= 3)
stop("not a square matrix of n>3")
n <- ncol(A)
L <- matrix(as.numeric(NA), nrow = n, ncol = n)
L[1,1] <- sqrt(A[1,1])
L[-1,1] <- A[-1,1]/L[1,1]
for(i in 2:(ncol(A)-1)){
L[i,i] <- sqrt(A[i,i] - sum(L[i,-(i:n)]^2) )
L[-(1:i),i] <- c(A[-(1:i),i,drop=F] - L[-(1:i),1:(i-1),drop=F] %*% t(L[i,1:(i-1),drop=F]))/L[i,i]
}
L[n,n] <- sqrt(A[n,n] - sum(L[n,-n]^2) )
L[is.na(L)] <- 0
return(L)
}
mat <- matrix(runif(100), ncol = 10, nrow = 10)
mat <- mat %*% t(mat)
l_cho = cholesky1(mat)
norm((l_cho %*% t(l_cho)) - mat, "F")
l_cho
cholesky_r <- function(A){
if(class(A) != "matrix")
stop(paste0("found ",class(A), ", expected matrix"))
if((ncol(A) != nrow(A)) | nrow(A) <= 3)
stop("not a square matrix of n>3")
n = ncol(A)
L = matrix(as.numeric(NA), nrow = n, ncol = n)
L[1,1] = sqrt(A[1,1])
L[-1,1] = A[-1,1]/L[1,1]
for(i in 2:(ncol(A)-1)){
L[i,i] = sqrt(A[i,i] - sum(L[i,-(i:n)]^2) )
L[-(1:i),i] = c(A[-(1:i),i,drop=F] - L[-(1:i),1:(i-1),drop=F] %*% t(L[i,1:(i-1),drop=F]))/L[i,i]
}
L[n,n] = sqrt(A[n,n] - sum(L[n,-n]^2) )
L[is.na(L)] = 0
return(L)
}
mat = matrix(runif(100), ncol = 10, nrow = 10)
mat = mat %*% t(mat)
l_cho = cholesky_r(mat)
norm((l_cho %*% t(l_cho)) - mat, "F")
cholesky_r <- function(A){
if(class(A) != "matrix")
stop(paste0("found ",class(A), ", expected matrix"))
if((ncol(A) != nrow(A)) | nrow(A) <= 3)
stop("not a square matrix of n>3")
n = ncol(A)
L = matrix(as.numeric(NA), nrow = n, ncol = n)
L[1,1] = sqrt(A[1,1])
L[-1,1] = A[-1,1]/L[1,1]
for(i in 2:(ncol(A)-1)){
L[i,i] = sqrt(A[i,i] - sum(L[i,-(i:n)]^2) )
L[-(1:i),i] = c(A[-(1:i),i,drop=F] - L[-(1:i),1:(i-1),drop=F] %*% t(L[i,1:(i-1),drop=F]))/L[i,i]
}
L[n,n] = sqrt(A[n,n] - sum(L[n,-n]^2) )
L[is.na(L)] = 0
return(L)
}
set.seed(84)
mat = matrix(rnorm(100), ncol = 10, nrow = 10)
mat = mat %*% t(mat)
l_cho = cholesky_r(mat)
norm((l_cho %*% t(l_cho)) - mat, "F")
l_cho
